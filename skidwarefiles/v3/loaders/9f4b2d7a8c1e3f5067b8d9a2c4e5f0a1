task.wait();
repeat
    task.wait();
until game:IsLoaded() 
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

local Alive = Workspace:FindFirstChild("Alive")
local Aerodynamic = false
local Aerodynamic_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Key = nil
local Remotes = {}
local revertedRemotes = {}
local originalMetatables = {}
local Parries = 0
local Connections_Manager = {}
local Animation = {storage = {}, current = nil, track = nil}

local function isValidRemoteArgs(args)
    return #args == 7 and
           type(args[2]) == "string" and  
           type(args[3]) == "number" and 
           typeof(args[4]) == "CFrame" and 
           type(args[5]) == "table" and  
           type(args[6]) == "table" and 
           type(args[7]) == "boolean"
end
local function hookRemote(remote)
    if not revertedRemotes[remote] then
        if not originalMetatables[getmetatable(remote)] then
            originalMetatables[getmetatable(remote)] = true

            local meta = getrawmetatable(remote)
            setreadonly(meta, false)

            local oldIndex = meta.__index
            meta.__index = function(self, key)
                if (key == "FireServer" and self:IsA("RemoteEvent")) or (key == "InvokeServer" and self:IsA("RemoteFunction")) then
                    return function(_, ...)
                        local args = {...}
                        if isValidRemoteArgs(args) then
                            if not revertedRemotes[self] then
                                revertedRemotes[self] = args
                                
                                local remoteType = self:IsA("RemoteEvent") and "RemoteEvent" or "RemoteFunction"
                                local remoteData = {
                                    RemoteName = self.Name,
                                    RemoteType = remoteType,
                                    Args = args
                                }
                                setclipboard(game:GetService("HttpService"):JSONEncode(remoteData))
                                game.StarterGui:SetCore("SendNotification", {
                                    Title = "Auto Parry Loaded",
                                    Text = "V1!",
                                    Duration = 5,
                                })
                            end
                        end
                        return oldIndex(self, key)(_, unpack(args))
                    end
                end
                return oldIndex(self, key)
            end

            setreadonly(meta, true)
        end
    end
end

local function restoreRemotes()
    for remote, _ in pairs(revertedRemotes) do
        if originalMetatables[getmetatable(remote)] then
            local meta = getrawmetatable(remote)
            setreadonly(meta, false)
            meta.__index = nil
            setreadonly(meta, true)
        end
    end
    revertedRemotes = {}
    print("Remotes restored.")
end

for _, remote in pairs(game.ReplicatedStorage:GetChildren()) do
    if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
        hookRemote(remote)
    end
end

game.ReplicatedStorage.ChildAdded:Connect(function(child)
    if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
        hookRemote(child)
    end
end)

local function createAnimation(object, info, value)
	local animation = TweenService:Create(object, info, value);
	animation:Play();
	task.wait(info.Time);
	Debris:AddItem(animation, 0);
	animation:Destroy();
end
for _, animation in pairs(ReplicatedStorage.Misc.Emotes:GetChildren()) do
	if (animation:IsA("Animation") and animation:GetAttribute("EmoteName")) then
		local emoteName = animation:GetAttribute("EmoteName");
		Animation.storage[emoteName] = animation;
	end
end

local Key = Parry_Key;
local Auto_Parry = {};
Auto_Parry.Parry_Animation = function()
	local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild("GrabParry");
	local Current_Sword = LocalPlayer.Character:GetAttribute("CurrentlyEquippedSword");
	if (not Current_Sword or not Parry_Animation) then
		return;
	end
	local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword);
	if (not Sword_Data or not Sword_Data['AnimationType']) then
		return;
	end
	for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
		if (object.Name == Sword_Data['AnimationType']) then
			local sword_animation_type = (object:FindFirstChild("GrabParry") and "GrabParry") or "Grab";
			Parry_Animation = object[sword_animation_type];
		end
	end
	Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation);
	Grab_Parry:Play();
end;
Auto_Parry.Play_Animation = function(animationName)
	local Animations = Animation.storage[animationName];
	if not Animations then
		return false;
	end
	local Animator = LocalPlayer.Character.Humanoid.Animator;
	if (Animation.track and Animation.track:IsA("AnimationTrack")) then
		Animation.track:Stop();
	end
	Animation.track = Animator:LoadAnimation(Animations);
	if (Animation.track and Animation.track:IsA("AnimationTrack")) then
		Animation.track:Play();
	end
	Animation.current = animationName;
end;
Auto_Parry.Get_Balls = function()
	local Balls = {};
	for _, instance in pairs(Workspace.Balls:GetChildren()) do
		if instance:GetAttribute("realBall") then
			instance.CanCollide = false;
			table.insert(Balls, instance);
		end
	end
	return Balls;
end;
Auto_Parry.Get_Ball = function()
	for _, instance in pairs(Workspace.Balls:GetChildren()) do
		if instance:GetAttribute("realBall") then
			instance.CanCollide = false;
			return instance;
		end
	end
end;
Auto_Parry.Parry_Data = function()
	local Events = {};
	local Camera = workspace.CurrentCamera;
	if ((Last_Input == Enum.UserInputType.MouseButton1) or (Last_Input == Enum.UserInputType.MouseButton2) or (Last_Input == Enum.UserInputType.Keyboard)) then
		local Mouse_Location = UserInputService:GetMouseLocation();
		Vector2_Mouse_Location = {Mouse_Location.X,Mouse_Location.Y};
	else
		Vector2_Mouse_Location = {(Camera.ViewportSize.X / 2),(Camera.ViewportSize.Y / 2)};
	end
	for _, v in pairs(workspace.Alive:GetChildren()) do
		if (v:IsA("Model") and v.PrimaryPart) then
			Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position);
		end
	end
	return {0,Camera.CFrame,Events,Vector2_Mouse_Location};
end;
local Parry_Method = "Remote"
local FirstParryDone = false 

function Auto_Parry.Parry(Parry_Type)
    local Parry_Data = Auto_Parry.Parry_Data(Parry_Type)
    
    if not FirstParryDone then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        task.wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        FirstParryDone = true 
    else
        for remote, args in pairs(revertedRemotes) do
            if remote:IsA("RemoteEvent") then
                remote:FireServer(unpack(args))
            elseif remote:IsA("RemoteFunction") then
                remote:InvokeServer(unpack(args))
            end
        end
    end

    if Parries > 7 then
        return false
    end

    Parries += 1

    task.delay(0.7, function()
        if Parries > 0 then
            Parries -= 1
        end
    end)
end
local Lerp_Radians = 0;
local Last_Warping = tick();
Auto_Parry.Linear_Interpolation = function(a, b, time_volume)
	return a + ((b - a) * time_volume);
end;
local Previous_Velocity = {};
local Curving = tick();
Auto_Parry.Is_Curved = function()
	local Ball = Auto_Parry.Get_Ball();
	if not Ball then
		return false;
	end
	local Zoomies = Ball:FindFirstChild("zoomies");
	if not Zoomies then
		return false;
	end
	local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue();
	local Velocity = Zoomies.VectorVelocity;
	local Ball_Direction = Velocity.Unit;
	local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit;
	local Dot = Direction:Dot(Ball_Direction);
	local Speed = Velocity.Magnitude;
	local Speed_Threshold = math.min(Speed / 100, 40);
	local Angle_Threshold = 40 * math.max(Dot, 0);
	local Direction_Difference = (Ball_Direction - Velocity).Unit;
	local Direction_Similarity = Direction:Dot(Direction_Difference);
	local Dot_Difference = Dot - Direction_Similarity;
	local Dot_Threshold = 0.5 - (Ping / 1000);
	local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude;
	local Reach_Time = (Distance / Speed) - (Ping / 1000);
	local Enough_Speed = Speed > 100;
	local Ball_Distance_Threshold = (15 - math.min(Distance / 1000, 15)) + Angle_Threshold + Speed_Threshold;
	table.insert(Previous_Velocity, Velocity);
	if (#Previous_Velocity > 4) then
		table.remove(Previous_Velocity, 1);
	end
	if (Enough_Speed and (Reach_Time > (Ping / 10))) then
		Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 15, 15);
	end
	if (Distance < Ball_Distance_Threshold) then
		return false;
	end
	if ((tick() - Curving) < (Reach_Time / 1.5)) then
		return true;
	end
	if (Dot_Difference < Dot_Threshold) then
		return true;
	end
	local Radians = math.asin(Dot);
	Lerp_Radians = Auto_Parry.Linear_Interpolation(Lerp_Radians, Radians, 0.8);
	if (Lerp_Radians < 0.018) then
		Last_Warping = tick();
	end
	if ((tick() - Last_Warping) < (Reach_Time / 1.5)) then
		return true;
	end
	if (#Previous_Velocity == 4) then
		for i = 1, 2 do
			local Intended_Direction_Difference = (Ball_Direction - Previous_Velocity[i].Unit).Unit;
			local Intended_Dot = Direction:Dot(Intended_Direction_Difference);
			local Intended_Dot_Difference = Dot - Intended_Dot;
			if (Intended_Dot_Difference < Dot_Threshold) then
				return true;
			end
		end
	end
	return Dot < Dot_Threshold;
end;
Auto_Parry.Closest_Player = function()
	local Max_Distance = math.huge;
	Closest_Entity = nil;
	for _, Entity in pairs(Workspace.Alive:GetChildren()) do
		if ((tostring(Entity) ~= tostring(LocalPlayer)) and Entity.PrimaryPart) then
			local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position);
			if (Distance < Max_Distance) then
				Max_Distance = Distance;
				Closest_Entity = Entity;
			end
		end
	end
	return Closest_Entity;
end;
Auto_Parry.Get_Entity_Properties = function(self)
	Auto_Parry.Closest_Player();
	if not Closest_Entity then
		return false;
	end
	local entityVelocity = Closest_Entity.PrimaryPart.Velocity;
	local entityDirection = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit;
	local entityDistance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude;
	return {Velocity=entityVelocity,Direction=entityDirection,Distance=entityDistance};
end;
Auto_Parry.Get_Ball_Properties = function(self)
	local ball = Auto_Parry.Get_Ball();
	if not ball then
		return false;
	end
	local character = LocalPlayer.Character;
	if (not character or not character.PrimaryPart) then
		return false;
	end
	local ballVelocity = ball.AssemblyLinearVelocity;
	local ballDirection = (character.PrimaryPart.Position - ball.Position).Unit;
	local ballDistance = (character.PrimaryPart.Position - ball.Position).Magnitude;
	local ballDot = ballDirection:Dot(ballVelocity.Unit);
	return {Velocity=ballVelocity,Direction=ballDirection,Distance=ballDistance,Dot=ballDot};
end;
Auto_Parry.Spam_Service = function(self)
    local ball = Auto_Parry.Get_Ball();
    if not ball then
        return false;
    end
    Auto_Parry.Closest_Player();
    local spamDelay = 0;
    local spamAccuracy = 100;
    if not self.Spam_Sensitivity then
        self.Spam_Sensitivity = 75;
    end
    if not self.Ping_Based_Spam then
        self.Ping_Based_Spam = false;
    end
    local velocity = ball.AssemblyLinearVelocity;
    local speed = velocity.Magnitude;
    local direction = (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Unit;
    local dot = direction:Dot(velocity.Unit);
    local targetPosition = Closest_Entity and Closest_Entity.PrimaryPart and Closest_Entity.PrimaryPart.Position;
    if not targetPosition then
        return spamAccuracy;
    end
    local targetDistance = LocalPlayer:DistanceFromCharacter(targetPosition);
    local maximumSpamDistance = self.Ping + math.min(speed / 5, 100);
    maximumSpamDistance = maximumSpamDistance * self.Spam_Sensitivity;
    if self.Ping_Based_Spam then
        maximumSpamDistance = maximumSpamDistance + self.Ping;
    end
    if ((self.Entity_Properties.Distance > maximumSpamDistance) or (self.Ball_Properties.Distance > maximumSpamDistance) or (targetDistance > maximumSpamDistance)) then
        return spamAccuracy;
    end
    local maximumSpeed = 5 - math.min(speed / 5, 5);
    local maximumDot = math.clamp(dot, -1, 0) * maximumSpeed;
    spamAccuracy = maximumSpamDistance - maximumDot;
    task.wait(0.00000000000000000000000000000000000000000000000001);
    return spamAccuracy;
end;
local visualizerEnabled = false;
local function get_character()
	return LocalPlayer and LocalPlayer.Character;
end
local function get_primary_part()
	local char = get_character();
	return char and char.PrimaryPart;
end
local function get_ball()
	local ballContainer = Workspace:FindFirstChild("Balls");
	if ballContainer then
		for _, ball in ipairs(ballContainer:GetChildren()) do
			if not ball.Anchored then
				return ball;
			end
		end
	end
	return nil;
end
local function calculate_visualizer_radius()
	local ball = get_ball();
	if ball then
		local velocity = ball.Velocity.Magnitude;
		return math.clamp((velocity / 2.4) + 10, 15, 200);
	end
	return 15;
end
local visualizer = Instance.new("Part");
visualizer.Shape = Enum.PartType.Ball;
visualizer.Anchored = true;
visualizer.CanCollide = false;
visualizer.Material = Enum.Material.ForceField;
visualizer.Transparency = 0.5;
visualizer.Parent = Workspace;
visualizer.Size = Vector3.new(0, 0, 0);
local function toggle_visualizer(state)
	visualizerEnabled = state;
	if not state then
		visualizer.Size = Vector3.new(0, 0, 0);
	end
end
RunService.RenderStepped:Connect(function()
	if not visualizerEnabled then
		return;
	end
	local primaryPart = get_primary_part();
	local ball = get_ball();
	if (primaryPart and ball) then
		local radius = calculate_visualizer_radius();
		local isHighlighted = primaryPart:FindFirstChild("Highlight");
		visualizer.Size = Vector3.new(radius, radius, radius);
		visualizer.CFrame = primaryPart.CFrame;
		visualizer.Color = isHighlighted and Color3.fromRGB(255, 255, 255);
	else
		visualizer.Size = Vector3.new(0, 0, 0);
	end
end);

-- Load the library
local Library = loadstring(game:HttpGet("https://pastefy.app/tXObfOAY/raw"))()
local main = Library.new()

-- Tabs
local auto_parry_tab = main:create_tab("Auto Parry", "rbxassetid://76499042599127")
local Detection = main:create_tab("Detections", "rbxassetid://76499042599127")
local Exclusive = main:create_tab("Exclusive", "rbxassetid://10709782497")

-- Auto Parry Module
local auto_parry = auto_parry_tab:create_module({
    title = "Auto Parry",
    flag = "Auto_Parry",
    description = "Automatically parries enemy attacks with 100% accuracy",
    section = "left",
    callback = function(value)
        Library._config._flags["Auto_Parry"] = value
        if Connections_Manager["Auto Parry"] then
            Connections_Manager["Auto Parry"]:Disconnect()
            Connections_Manager["Auto Parry"] = nil
        end
        if value then
            Connections_Manager["Auto Parry"] = RunService.PreSimulation:Connect(function()
                if not Library._config._flags["Auto_Parry"] then
                    return
                end
                local isInAlive = Workspace.Alive:FindFirstChild(tostring(LocalPlayer)) ~= nil
                local One_Ball = Auto_Parry.Get_Ball(isInAlive)
                local Balls = Auto_Parry.Get_Balls(isInAlive)
                if not Balls or #Balls == 0 then
                    return
                end
                for _, Ball in pairs(Balls) do
                    if not Ball then
                        return
                    end
                    local Zoomies = Ball:FindFirstChild("zoomies")
                    if not Zoomies then
                        return
                    end
                    Ball:GetAttributeChangedSignal("target"):Once(function()
                        Parried = false
                    end)
                    if Parried then
                        return
                    end
                    local Ball_Target = Ball:GetAttribute("target")
                    local One_Target = One_Ball and One_Ball:GetAttribute("target")
                    local Velocity = Zoomies.VectorVelocity
                    local character = LocalPlayer.Character
                    if not character or not character.PrimaryPart then
                        return
                    end
                    local Distance = (character.PrimaryPart.Position - Ball.Position).Magnitude
                    local Speed = Velocity.Magnitude
                    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
                    local Parry_Accuracy = (Speed / 3) + Ping - 5
                    local Curved = Auto_Parry.Is_Curved(isInAlive)
                    if Ball_Target == tostring(LocalPlayer) and Aerodynamic then
                        local Elapsed_Tornado = tick() - Aerodynamic_Time
                        if Elapsed_Tornado > 0.5 then
                            Aerodynamic_Time = tick()
                            Aerodynamic = false
                        end
                        return
                    end
                    if One_Target == tostring(LocalPlayer) and Curved then
                        return
                    end
                    if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy + 3 then
                        Auto_Parry.Parry()
                        Parried = true
                    end
                    local Last_Parrys = tick()
                    while (tick() - Last_Parrys) < 0.8 do
                        if not Parried then
                            break
                        end
                        task.wait()
                    end
                    Parried = false
                end
            end)
        end
        Library.SendNotification({title = "Auto Parry", text = value and "Enabled!" or "Disabled!", duration = 3})
    end
})

local lobby_auto_parry = auto_parry_tab:create_module({
    title = "Lobby Auto Parry",
    flag = "Lobby_Auto_Parry",
    description = "Automatically parries in lobby using TrainingBalls or Balls",
    section = "left",
    callback = function(value)
        Library._config._flags["Lobby_Auto_Parry"] = value
        if Connections_Manager["Lobby Auto Parry"] then
            Connections_Manager["Lobby Auto Parry"]:Disconnect()
            Connections_Manager["Lobby Auto Parry"] = nil
        end
        if value then
            Connections_Manager["Lobby Auto Parry"] = RunService.PreSimulation:Connect(function()
                if not Library._config._flags["Lobby_Auto_Parry"] then
                    return
                end
                local isInAlive = Workspace.Alive:FindFirstChild(tostring(LocalPlayer)) ~= nil
                local One_Ball = Auto_Parry.Get_Ball(isInAlive)
                local Balls = Auto_Parry.Get_Balls(isInAlive)
                if not Balls or #Balls == 0 then
                    return
                end
                for _, Ball in pairs(Balls) do
                    if not Ball then
                        return
                    end
                    local Zoomies = Ball:FindFirstChild("zoomies")
                    if not Zoomies then
                        return
                    end
                    Ball:GetAttributeChangedSignal("target"):Once(function()
                        Parried = false
                    end)
                    if Parried then
                        return
                    end
                    local Ball_Target = Ball:GetAttribute("target")
                    local One_Target = One_Ball and One_Ball:GetAttribute("target")
                    local Velocity = Zoomies.VectorVelocity
                    local character = LocalPlayer.Character
                    if not character or not character.PrimaryPart then
                        return
                    end
                    local Distance = (character.PrimaryPart.Position - Ball.Position).Magnitude
                    local Speed = Velocity.Magnitude
                    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
                    local Parry_Accuracy = (Speed / 3) + Ping - 5
                    local Curved = Auto_Parry.Is_Curved(isInAlive)
                    if Ball_Target == tostring(LocalPlayer) and Aerodynamic then
                        local Elapsed_Tornado = tick() - Aerodynamic_Time
                        if Elapsed_Tornado > 0.5 then
                            Aerodynamic_Time = tick()
                            Aerodynamic = false
                        end
                        return
                    end
                    if One_Target == tostring(LocalPlayer) and Curved then
                        return
                    end
                    if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy + 3 then
                        Auto_Parry.Parry()
                        Parried = true
                    end
                    local Last_Parrys = tick()
                    while (tick() - Last_Parrys) < 0.8 do
                        if not Parried then
                            break
                        end
                        task.wait()
                    end
                    Parried = false
                end
            end)
        end
        Library.SendNotification({title = "Lobby Auto Parry", text = value and "Enabled!" or "Disabled!", duration = 3})
    end
})

local auto_Spam = auto_parry_tab:create_module({
    title = "Auto Spam",
    flag = "Auto_Spam",
    description = "Auto Spams When Needed",
    section = "right",
    callback = function(value)
        Library._config._flags["Auto_Spam"] = value
        if autoSpamCoroutine then
            coroutine.resume(autoSpamCoroutine, "stop")
            autoSpamCoroutine = nil
        end
        if value then
            autoSpamCoroutine = coroutine.create(function(signal)
                while Library._config._flags["Auto_Spam"] and signal ~= "stop" do
                    local isInAlive = Workspace.Alive:FindFirstChild(tostring(LocalPlayer)) ~= nil
                    local ball = Auto_Parry.Get_Ball(isInAlive)
                    if not ball or not ball:IsDescendantOf(Workspace) then
                        task.wait(1e-30)
                        continue
                    end
                    local zoomies = ball:FindFirstChild("zoomies")
                    if not zoomies then
                        task.wait(1e-30)
                        continue
                    end
                    Auto_Parry.Closest_Player()
                    local targetPlayer = _G.Closest_Entity
                    if not targetPlayer or not targetPlayer.PrimaryPart or not targetPlayer:IsDescendantOf(Workspace) then
                        task.wait(1e-30)
                        continue
                    end
                    local playerDistance = LocalPlayer:DistanceFromCharacter(ball.Position)
                    local targetPosition = targetPlayer.PrimaryPart.Position
                    local targetDistance = LocalPlayer:DistanceFromCharacter(targetPosition)
                    if not targetPlayer.Parent then
                        task.wait(1e-30)
                        continue
                    end
                    if not ball:IsDescendantOf(Workspace) or ball.Position.Magnitude < 1 then
                        local waitTime = 0
                        repeat
                            task.wait(1e-30)
                            waitTime = waitTime + 1e-30
                            ball = Auto_Parry.Get_Ball(isInAlive)
                        until (ball and ball:IsDescendantOf(Workspace) and ball.Position.Magnitude > 1) or waitTime >= 2.5
                        continue
                    end
                    local ballVelocity = ball.Velocity.Magnitude
                    local ballSpeed = math.max(ballVelocity, 0)
                    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
                    local pingThreshold = math.clamp(ping / 10, 6, 12)
                    local ballProperties = Auto_Parry:Get_Ball_Properties(isInAlive)
                    local entityProperties = Auto_Parry:Get_Entity_Properties()
                    local spamAccuracy = Auto_Parry.Spam_Service({
                        Ball_Properties = ballProperties,
                        Entity_Properties = entityProperties,
                        Ping = pingThreshold,
                        Spam_Sensitivity = Library._config._flags["Parry_Sensitivity"] or 100,
                        Ping_Based_Spam = true,
                        isInAlive = isInAlive
                    })
                    local spamThreshold = Library._config._flags["Spam_Therhold"] or 2
                    if zoomies and zoomies.Parent == ball and (playerDistance <= 25 or targetDistance <= 25) and Parries > spamThreshold then
                        Auto_Parry.Parry()
                    end
                    local waitTime = spamThreshold < 1 and 1e-31 or 1e-30
                    task.wait(waitTime)
                end
            end)
            coroutine.resume(autoSpamCoroutine)
        end
        Library.SendNotification({title = "Auto Spam", text = value and "Enabled!" or "Disabled!", duration = 3})
    end
})

main:load()
