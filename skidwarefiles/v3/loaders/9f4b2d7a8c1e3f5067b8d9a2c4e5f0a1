task.wait()
repeat
    task.wait()
until game:IsLoaded()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

local Alive = Workspace:FindFirstChild("Alive")
local Aerodynamic = false
local Aerodynamic_Time = tick()
local Last_Input = UserInputService:GetLastInputType()
local Vector2_Mouse_Location = nil
local Grab_Parry = nil
local Parry_Key = nil
local Remotes = {}
local revertedRemotes = {}
local originalMetatables = {}
local Parries = 0
local Connections_Manager = {}
local Animation = {storage = {}, current = nil, track = nil}

local function isValidRemoteArgs(args)
    return #args == 7 and
           type(args[2]) == "string" and
           type(args[3]) == "number" and
           typeof(args[4]) == "CFrame" and
           type(args[5]) == "table" and
           type(args[6]) == "table" and
           type(args[7]) == "boolean"
end

local function hookRemote(remote)
    if not revertedRemotes[remote] then
        if not originalMetatables[getmetatable(remote)] then
            originalMetatables[getmetatable(remote)] = true
            local meta = getrawmetatable(remote)
            setreadonly(meta, false)
            local oldIndex = meta.__index
            meta.__index = function(self, key)
                if (key == "FireServer" and self:IsA("RemoteEvent")) or (key == "InvokeServer" and self:IsA("RemoteFunction")) then
                    return function(_, ...)
                        local args = {...}
                        if isValidRemoteArgs(args) then
                            if not revertedRemotes[self] then
                                revertedRemotes[self] = args
                                local remoteType = self:IsA("RemoteEvent") and "RemoteEvent" or "RemoteFunction"
                                local remoteData = {
                                    RemoteName = self.Name,
                                    RemoteType = remoteType,
                                    Args = args
                                }
                                setclipboard(game:GetService("HttpService"):JSONEncode(remoteData))
                                game.StarterGui:SetCore("SendNotification", {
                                    Title = "Auto Parry Loaded",
                                    Text = "V1!",
                                    Duration = 5
                                })
                            end
                        end
                        return oldIndex(self, key)(_, unpack(args))
                    end
                end
                return oldIndex(self, key)
            end
            setreadonly(meta, true)
        end
    end
end

local function restoreRemotes()
    for remote, _ in pairs(revertedRemotes) do
        if originalMetatables[getmetatable(remote)] then
            local meta = getrawmetatable(remote)
            setreadonly(meta, false)
            meta.__index = nil
            setreadonly(meta, true)
        end
    end
    revertedRemotes = {}
    print("Remotes restored.")
end

for _, remote in pairs(game.ReplicatedStorage:GetChildren()) do
    if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
        hookRemote(remote)
    end
end

game.ReplicatedStorage.ChildAdded:Connect(function(child)
    if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
        hookRemote(child)
    end
end)

local function createAnimation(object, info, value)
    local animation = TweenService:Create(object, info, value)
    animation:Play()
    task.wait(info.Time)
    Debris:AddItem(animation, 0)
    animation:Destroy()
end

for _, animation in pairs(ReplicatedStorage.Misc.Emotes:GetChildren()) do
    if animation:IsA("Animation") and animation:GetAttribute("EmoteName") then
        local emoteName = animation:GetAttribute("EmoteName")
        Animation.storage[emoteName] = animation
    end
end

local Auto_Parry = {}

Auto_Parry.Parry_Animation = function()
    local Parry_Animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild("GrabParry")
    local Current_Sword = LocalPlayer.Character:GetAttribute("CurrentlyEquippedSword")
    if not Current_Sword or not Parry_Animation then
        return
    end
    local Sword_Data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(Current_Sword)
    if not Sword_Data or not Sword_Data['AnimationType'] then
        return
    end
    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == Sword_Data['AnimationType'] then
            local sword_animation_type = object:FindFirstChild("GrabParry") and "GrabParry" or "Grab"
            Parry_Animation = object[sword_animation_type]
        end
    end
    Grab_Parry = LocalPlayer.Character.Humanoid.Animator:LoadAnimation(Parry_Animation)
    Grab_Parry:Play()
end

Auto_Parry.Play_Animation = function(animationName)
    local Animations = Animation.storage[animationName]
    if not Animations then
        return false
    end
    local Animator = LocalPlayer.Character.Humanoid.Animator
    if Animation.track and Animation.track:IsA("AnimationTrack") then
        Animation.track:Stop()
    end
    Animation.track = Animator:LoadAnimation(Animations)
    if Animation.track and Animation.track:IsA("AnimationTrack") then
        Animation.track:Play()
    end
    Animation.current = animationName
end

Auto_Parry.Get_Balls = function(isInAlive)
    local ballFolder = Workspace:FindFirstChild(isInAlive and "Balls" or "TrainingBalls")
    local Balls = {}
    if ballFolder then
        for _, instance in pairs(ballFolder:GetChildren()) do
            if instance:GetAttribute("realBall") then
                instance.CanCollide = false
                table.insert(Balls, instance)
            end
        end
    end
    return Balls
end

Auto_Parry.Get_Ball = function(isInAlive)
    local ballFolder = Workspace:FindFirstChild(isInAlive and "Balls" or "TrainingBalls")
    if ballFolder then
        for _, instance in pairs(ballFolder:GetChildren()) do
            if instance:GetAttribute("realBall") then
                instance.CanCollide = false
                return instance
            end
        end
    end
end

Auto_Parry.Parry_Data = function()
    local Events = {}
    local Camera = workspace.CurrentCamera
    if Last_Input == Enum.UserInputType.MouseButton1 or Last_Input == Enum.UserInputType.MouseButton2 or Last_Input == Enum.UserInputType.Keyboard then
        local Mouse_Location = UserInputService:GetMouseLocation()
        Vector2_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    else
        Vector2_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end
    for _, v in pairs(workspace.Alive:GetChildren()) do
        if v:IsA("Model") and v.PrimaryPart then
            Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
        end
    end
    return {0, Camera.CFrame, Events, Vector2_Mouse_Location}
end

local Parry_Method = "Remote"
local FirstParryDone = false

function Auto_Parry.Parry(Parry_Type)
    local Parry_Data = Auto_Parry.Parry_Data(Parry_Type)
    if not FirstParryDone then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
        FirstParryDone = true
    else
        for remote, args in pairs(revertedRemotes) do
            if remote:IsA("RemoteEvent") then
                remote:FireServer(unpack(args))
            elseif remote:IsA("RemoteFunction") then
                remote:InvokeServer(unpack(args))
            end
        end
    end
    if Parries > 5 then
        return false
    end
    Parries += 1
    task.delay(0.5, function()
        if Parries > 0 then
            Parries -= 1
        end
    end)
end

local Lerp_Radians = 0
local Last_Warping = tick()
Auto_Parry.Linear_Interpolation = function(a, b, time_volume)
    return a + ((b - a) * time_volume)
end

local Previous_Velocity = {}
local Curving = tick()
Auto_Parry.Is_Curved = function(isInAlive)
    local Ball = Auto_Parry.Get_Ball(isInAlive)
    if not Ball then
        return false
    end
    local Zoomies = Ball:FindFirstChild("zoomies")
    if not Zoomies then
        return false
    end
    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
    local Velocity = Zoomies.VectorVelocity
    local Ball_Direction = Velocity.Unit
    local Direction = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Unit
    local Dot = Direction:Dot(Ball_Direction)
    local Speed = Velocity.Magnitude
    local Speed_Threshold = math.min(Speed / 80, 30)
    local Angle_Threshold = 30 * math.max(Dot, 0)
    local Direction_Difference = (Ball_Direction - Velocity).Unit
    local Direction_Similarity = Direction:Dot(Direction_Difference)
    local Dot_Difference = Dot - Direction_Similarity
    local Dot_Threshold = 0.4 - (Ping / 1000)
    local Distance = (LocalPlayer.Character.PrimaryPart.Position - Ball.Position).Magnitude
    local Reach_Time = (Distance / Speed) - (Ping / 1000)
    local Enough_Speed = Speed > 80
    local Ball_Distance_Threshold = (10 - math.min(Distance / 1000, 10)) + Angle_Threshold + Speed_Threshold
    table.insert(Previous_Velocity, Velocity)
    if #Previous_Velocity > 4 then
        table.remove(Previous_Velocity, 1)
    end
    if Enough_Speed and Reach_Time > (Ping / 10) then
        Ball_Distance_Threshold = math.max(Ball_Distance_Threshold - 10, 10)
    end
    if Distance < Ball_Distance_Threshold then
        return false
    end
    if (tick() - Curving) < (Reach_Time / 1.2) then
        return true
    end
    if Dot_Difference < Dot_Threshold then
        return true
    end
    local Radians = math.asin(Dot)
    Lerp_Radians = Auto_Parry.Linear_Interpolation(Lerp_Radians, Radians, 0.9)
    if Lerp_Radians < 0.015 then
        Last_Warping = tick()
    end
    if (tick() - Last_Warping) < (Reach_Time / 1.2) then
        return true
    end
    if #Previous_Velocity == 4 then
        for i = 1, 2 do
            local Intended_Direction_Difference = (Ball_Direction - Previous_Velocity[i].Unit).Unit
            local Intended_Dot = Direction:Dot(Intended_Direction_Difference)
            local Intended_Dot_Difference = Dot - Intended_Dot
            if Intended_Dot_Difference < Dot_Threshold then
                return true
            end
        end
    end
    return Dot < Dot_Threshold
end

Auto_Parry.Closest_Player = function()
    local Max_Distance = math.huge
    local Closest_Entity = nil
    for _, Entity in pairs(Workspace.Alive:GetChildren()) do
        if tostring(Entity) ~= tostring(LocalPlayer) and Entity.PrimaryPart then
            local Distance = LocalPlayer:DistanceFromCharacter(Entity.PrimaryPart.Position)
            if Distance < Max_Distance then
                Max_Distance = Distance
                Closest_Entity = Entity
            end
        end
    end
    return Closest_Entity
end

Auto_Parry.Get_Entity_Properties = function()
    local Closest_Entity = Auto_Parry.Closest_Player()
    if not Closest_Entity then
        return false
    end
    local entityVelocity = Closest_Entity.PrimaryPart.Velocity
    local entityDirection = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Unit
    local entityDistance = (LocalPlayer.Character.PrimaryPart.Position - Closest_Entity.PrimaryPart.Position).Magnitude
    return {Velocity = entityVelocity, Direction = entityDirection, Distance = entityDistance}
end

Auto_Parry.Get_Ball_Properties = function(isInAlive)
    local ball = Auto_Parry.Get_Ball(isInAlive)
    if not ball then
        return false
    end
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then
        return false
    end
    local ballVelocity = ball.AssemblyLinearVelocity
    local ballDirection = (character.PrimaryPart.Position - ball.Position).Unit
    local ballDistance = (character.PrimaryPart.Position - ball.Position).Magnitude
    local ballDot = ballDirection:Dot(ballVelocity.Unit)
    return {Velocity = ballVelocity, Direction = ballDirection, Distance = ballDistance, Dot = ballDot}
end

Auto_Parry.Spam_Service = function(self)
    local ball = Auto_Parry.Get_Ball(self.isInAlive)
    if not ball then
        return false
    end
    Auto_Parry.Closest_Player()
    local Closest_Entity = _G.Closest_Entity
    local spamDelay = 0
    local spamAccuracy = 100
    if not self.Spam_Sensitivity then
        self.Spam_Sensitivity = 100
    end
    if not self.Ping_Based_Spam then
        self.Ping_Based_Spam = true
    end
    local velocity = ball.AssemblyLinearVelocity
    local speed = velocity.Magnitude
    local direction = (LocalPlayer.Character.PrimaryPart.Position - ball.Position).Unit
    local dot = direction:Dot(velocity.Unit)
    local targetPosition = Closest_Entity and Closest_Entity.PrimaryPart and Closest_Entity.PrimaryPart.Position
    if not targetPosition then
        return spamAccuracy
    end
    local targetDistance = LocalPlayer:DistanceFromCharacter(targetPosition)
    local maximumSpamDistance = self.Ping + math.min(speed / 4, 80)
    maximumSpamDistance = maximumSpamDistance * self.Spam_Sensitivity
    if self.Ping_Based_Spam then
        maximumSpamDistance = maximumSpamDistance + self.Ping
    end
    if self.Entity_Properties.Distance > maximumSpamDistance or self.Ball_Properties.Distance > maximumSpamDistance or targetDistance > maximumSpamDistance then
        return spamAccuracy
    end
    local maximumSpeed = 4 - math.min(speed / 4, 4)
    local maximumDot = math.clamp(dot, -1, 0) * maximumSpeed
    spamAccuracy = maximumSpamDistance - maximumDot
    task.wait(0.00000000001)
    return spamAccuracy
end

local visualizerEnabled = false
local function get_character()
    return LocalPlayer and LocalPlayer.Character
end

local function get_primary_part()
    local char = get_character()
    return char and char.PrimaryPart
end

local function get_ball(isInAlive)
    local ballFolder = Workspace:FindFirstChild(isInAlive and "Balls" or "TrainingBalls")
    if ballFolder then
        for _, ball in ipairs(ballFolder:GetChildren()) do
            if not ball.Anchored then
                return ball
            end
        end
    end
    return nil
end

local function calculate_visualizer_radius()
    local ball = get_ball()
    if ball then
        local velocity = ball.Velocity.Magnitude
        return math.clamp((velocity / 2.4) + 10, 15, 200)
    end
    return 15
end

local visualizer = Instance.new("Part")
visualizer.Shape = Enum.PartType.Ball
visualizer.Anchored = true
visualizer.CanCollide = false
visualizer.Material = Enum.Material.ForceField
visualizer.Transparency = 0.5
visualizer.Parent = Workspace
visualizer.Size = Vector3.new(0, 0, 0)

local function toggle_visualizer(state)
    visualizerEnabled = state
    if not state then
        visualizer.Size = Vector3.new(0, 0, 0)
    end
end

RunService.RenderStepped:Connect(function()
    if not visualizerEnabled then
        return
    end
    local primaryPart = get_primary_part()
    local ball = get_ball()
    if primaryPart and ball then
        local radius = calculate_visualizer_radius()
        local isHighlighted = primaryPart:FindFirstChild("Highlight")
        visualizer.Size = Vector3.new(radius, radius, radius)
        visualizer.CFrame = primaryPart.CFrame
        visualizer.Color = isHighlighted and Color3.fromRGB(255, 255, 255)
    else
        visualizer.Size = Vector3.new(0, 0, 0)
    end
end)

-- Load the library
local Library = loadstring(game:HttpGet("https://pastefy.app/PICj5Dhy/raw"))()
local main = Library.new()

-- Tabs
local auto_parry_tab = main:create_tab("Auto Parry", "rbxassetid://76499042599127")
local Detection = main:create_tab("Detections", "rbxassetid://76499042599127")
local player_tab = main:create_tab("Player", "rbxassetid://126017907477623")
local world_tab = main:create_tab("World", "rbxassetid://10723415040")
local Exclusive = main:create_tab("Exclusive", "rbxassetid://10709782497")

-- Auto Parry Module
local auto_parry = auto_parry_tab:create_module({
    title = "Auto Parry",
    flag = "Auto_Parry",
    description = "Automatically parries enemy attacks with 100% accuracy",
    section = "left",
    callback = function(value)
        Library._config._flags["Auto_Parry"] = value
        if Connections_Manager["Auto Parry"] then
            Connections_Manager["Auto Parry"]:Disconnect()
            Connections_Manager["Auto Parry"] = nil
        end
        if value then
            Connections_Manager["Auto Parry"] = RunService.PreSimulation:Connect(function()
                if not Library._config._flags["Auto_Parry"] then
                    return
                end
                local isInAlive = Workspace.Alive:FindFirstChild(tostring(LocalPlayer)) ~= nil
                local One_Ball = Auto_Parry.Get_Ball(isInAlive)
                local Balls = Auto_Parry.Get_Balls(isInAlive)
                if not Balls or #Balls == 0 then
                    return
                end
                for _, Ball in pairs(Balls) do
                    if not Ball then
                        return
                    end
                    local Zoomies = Ball:FindFirstChild("zoomies")
                    if not Zoomies then
                        return
                    end
                    Ball:GetAttributeChangedSignal("target"):Once(function()
                        Parried = false
                    end)
                    if Parried then
                        return
                    end
                    local Ball_Target = Ball:GetAttribute("target")
                    local One_Target = One_Ball and One_Ball:GetAttribute("target")
                    local Velocity = Zoomies.VectorVelocity
                    local character = LocalPlayer.Character
                    if not character or not character.PrimaryPart then
                        return
                    end
                    local Distance = (character.PrimaryPart.Position - Ball.Position).Magnitude
                    local Speed = Velocity.Magnitude
                    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
                    local Parry_Accuracy = (Speed / 3) + Ping - 5
                    local Curved = Auto_Parry.Is_Curved(isInAlive)
                    if Ball_Target == tostring(LocalPlayer) and Aerodynamic then
                        local Elapsed_Tornado = tick() - Aerodynamic_Time
                        if Elapsed_Tornado > 0.5 then
                            Aerodynamic_Time = tick()
                            Aerodynamic = false
                        end
                        return
                    end
                    if One_Target == tostring(LocalPlayer) and Curved then
                        return
                    end
                    if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy + 3 then
                        Auto_Parry.Parry()
                        Parried = true
                    end
                    local Last_Parrys = tick()
                    while (tick() - Last_Parrys) < 0.8 do
                        if not Parried then
                            break
                        end
                        task.wait()
                    end
                    Parried = false
                end
            end)
        end
        Library.SendNotification({title = "Auto Parry", text = value and "Enabled!" or "Disabled!", duration = 3})
    end
})

-- Lobby Auto Parry Module
local lobby_auto_parry = auto_parry_tab:create_module({
    title = "Lobby Auto Parry",
    flag = "Lobby_Auto_Parry",
    description = "Automatically parries in lobby using TrainingBalls or Balls",
    section = "left",
    callback = function(value)
        Library._config._flags["Lobby_Auto_Parry"] = value
        if Connections_Manager["Lobby Auto Parry"] then
            Connections_Manager["Lobby Auto Parry"]:Disconnect()
            Connections_Manager["Lobby Auto Parry"] = nil
        end
        if value then
            Connections_Manager["Lobby Auto Parry"] = RunService.PreSimulation:Connect(function()
                if not Library._config._flags["Lobby_Auto_Parry"] then
                    return
                end
                local isInAlive = Workspace.Alive:FindFirstChild(tostring(LocalPlayer)) ~= nil
                local One_Ball = Auto_Parry.Get_Ball(isInAlive)
                local Balls = Auto_Parry.Get_Balls(isInAlive)
                if not Balls or #Balls == 0 then
                    return
                end
                for _, Ball in pairs(Balls) do
                    if not Ball then
                        return
                    end
                    local Zoomies = Ball:FindFirstChild("zoomies")
                    if not Zoomies then
                        return
                    end
                    Ball:GetAttributeChangedSignal("target"):Once(function()
                        Parried = false
                    end)
                    if Parried then
                        return
                    end
                    local Ball_Target = Ball:GetAttribute("target")
                    local One_Target = One_Ball and One_Ball:GetAttribute("target")
                    local Velocity = Zoomies.VectorVelocity
                    local character = LocalPlayer.Character
                    if not character or not character.PrimaryPart then
                        return
                    end
                    local Distance = (character.PrimaryPart.Position - Ball.Position).Magnitude
                    local Speed = Velocity.Magnitude
                    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
                    local Parry_Accuracy = (Speed / 3) + Ping - 5
                    local Curved = Auto_Parry.Is_Curved(isInAlive)
                    if Ball_Target == tostring(LocalPlayer) and Aerodynamic then
                        local Elapsed_Tornado = tick() - Aerodynamic_Time
                        if Elapsed_Tornado > 0.5 then
                            Aerodynamic_Time = tick()
                            Aerodynamic = false
                        end
                        return
                    end
                    if One_Target == tostring(LocalPlayer) and Curved then
                        return
                    end
                    if Ball_Target == tostring(LocalPlayer) and Distance <= Parry_Accuracy + 3 then
                        Auto_Parry.Parry()
                        Parried = true
                    end
                    local Last_Parrys = tick()
                    while (tick() - Last_Parrys) < 0.8 do
                        if not Parried then
                            break
                        end
                        task.wait()
                    end
                    Parried = false
                end
            end)
        end
        Library.SendNotification({title = "Lobby Auto Parry", text = value and "Enabled!" or "Disabled!", duration = 3})
    end
})

auto_parry:create_dropdown({
    title = "Curve Type",
    flag = "Curve_Type",
    options = {"Random", "Dot", "Backwards"},
    multi_dropdown = false,
    maximum_options = 1,
    callback = function(value)
        print("Curve Type:", value)
        Auto_Parry.Curve_Type = value
    end
})

auto_parry:create_slider({
    title = "Parry Sensitivity",
    flag = "Parry_Sensitivity",
    maximum_value = 100,
    minimum_value = 10,
    value = 100,
    round_number = true,
    callback = function(value)
        print("Parry Sensitivity:", value)
        Auto_Parry.Parry_Sensitivity = value
    end
})

auto_parry:create_checkbox({
    title = "Anti-Curve",
    flag = "Silent_Parry",
    callback = function(value)
        print("Anti-Curve:", value)
        if Connections_Manager["Anti_Curve_Parry"] then
            Connections_Manager["Anti_Curve_Parry"]:Disconnect()
            Connections_Manager["Anti_Curve_Parry"] = nil
        end
        if value then
            local previousVelocity = nil
            local curveDetected = false
            local curveDirection = nil
            local lastCurveTime = 0
            local curveCooldown = 0.5
            Connections_Manager["Anti_Curve_Parry"] = RunService.PreSimulation:Connect(function()
                if not Library._config._flags["Silent_Parry"] then
                    return
                end
                local isInAlive = Workspace.Alive:FindFirstChild(tostring(LocalPlayer)) ~= nil
                local Balls = Auto_Parry.Get_Balls(isInAlive)
                if not Balls or #Balls == 0 then
                    return
                end
                local character = LocalPlayer.Character
                if not character or not character.PrimaryPart then
                    return
                end
                for _, Ball in pairs(Balls) do
                    if not Ball then
                        return
                    end
                    local Zoomies = Ball:FindFirstChild("zoomies")
                    if not Zoomies then
                        return
                    end
                    Ball:GetAttributeChangedSignal("target"):Once(function()
                        Parried = false
                    end)
                    if Parried then
                        return
                    end
                    local Ball_Target = Ball:GetAttribute("target")
                    local Velocity = Zoomies.VectorVelocity
                    local Distance = (character.PrimaryPart.Position - Ball.Position).Magnitude
                    local Speed = Velocity.Magnitude
                    local Ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 10
                    local Parry_Accuracy = (Speed / 3) + Ping - 5
                    if previousVelocity then
                        local velocityChange = Velocity - previousVelocity
                        local changeMagnitude = velocityChange.Magnitude
                        local sensitivityThreshold = (Library._config._flags["Parry_Sensitivity"] or 100) / 10
                        if changeMagnitude > sensitivityThreshold then
                            local crossZ = previousVelocity.X * Velocity.Y - previousVelocity.Y * Velocity.X
                            curveDirection = crossZ > 0 and "left" or "right"
                            curveDetected = true
                            lastCurveTime = tick()
                        elseif tick() - lastCurveTime > curveCooldown then
                            curveDetected = false
                            curveDirection = nil
                        end
                    end
                    previousVelocity = Velocity
                    if Ball_Target == tostring(LocalPlayer) and curveDetected then
                        if Distance <= Parry_Accuracy + (curveDirection == "left" and 3 or 4) then
                            Auto_Parry.Parry()
                            Parried = true
                        end
                    elseif Ball_Target == tostring(LocalPlayer) then
                        if Distance <= Parry_Accuracy + 3 then
                            Auto_Parry.Parry()
                            Parried = true
                        end
                    end
                    local Last_Parrys = tick()
                    while (tick() - Last_Parrys) < 0.8 do
                        if not Parried then
                            break
                        end
                        task.wait()
                    end
                    Parried = false
                end
            end)
        end
    end
})

-- Auto Spam Module
local auto_Spam = auto_parry_tab:create_module({
    title = "Auto Spam",
    flag = "Auto_Spam",
    description = "Auto Spams When Needed",
    section = "right",
    callback = function(value)
        Library._config._flags["Auto_Spam"] = value
        if autoSpamCoroutine then
            coroutine.resume(autoSpamCoroutine, "stop")
            autoSpamCoroutine = nil
        end
        if value then
            autoSpamCoroutine = coroutine.create(function(signal)
                while Library._config._flags["Auto_Spam"] and signal ~= "stop" do
                    local isInAlive = Workspace.Alive:FindFirstChild(tostring(LocalPlayer)) ~= nil
                    local ball = Auto_Parry.Get_Ball(isInAlive)
                    if not ball or not ball:IsDescendantOf(Workspace) then
                        task.wait(1e-30)
                        continue
                    end
                    local zoomies = ball:FindFirstChild("zoomies")
                    if not zoomies then
                        task.wait(1e-30)
                        continue
                    end
                    Auto_Parry.Closest_Player()
                    local targetPlayer = _G.Closest_Entity
                    if not targetPlayer or not targetPlayer.PrimaryPart or not targetPlayer:IsDescendantOf(Workspace) then
                        task.wait(1e-30)
                        continue
                    end
                    local playerDistance = LocalPlayer:DistanceFromCharacter(ball.Position)
                    local targetPosition = targetPlayer.PrimaryPart.Position
                    local targetDistance = LocalPlayer:DistanceFromCharacter(targetPosition)
                    if not targetPlayer.Parent then
                        task.wait(1e-30)
                        continue
                    end
                    if not ball:IsDescendantOf(Workspace) or ball.Position.Magnitude < 1 then
                        local waitTime = 0
                        repeat
                            task.wait(1e-30)
                            waitTime = waitTime + 1e-30
                            ball = Auto_Parry.Get_Ball(isInAlive)
                        until (ball and ball:IsDescendantOf(Workspace) and ball.Position.Magnitude > 1) or waitTime >= 2.5
                        continue
                    end
                    local ballVelocity = ball.Velocity.Magnitude
                    local ballSpeed = math.max(ballVelocity, 0)
                    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
                    local pingThreshold = math.clamp(ping / 10, 6, 12)
                    local ballProperties = Auto_Parry:Get_Ball_Properties(isInAlive)
                    local entityProperties = Auto_Parry:Get_Entity_Properties()
                    local spamAccuracy = Auto_Parry.Spam_Service({
                        Ball_Properties = ballProperties,
                        Entity_Properties = entityProperties,
                        Ping = pingThreshold,
                        Spam_Sensitivity = Library._config._flags["Parry_Sensitivity"] or 100,
                        Ping_Based_Spam = true,
                        isInAlive = isInAlive
                    })
                    local spamThreshold = Library._config._flags["Spam_Therhold"] or 2
                    if zoomies and zoomies.Parent == ball and (playerDistance <= 25 or targetDistance <= 25) and Parries > spamThreshold then
                        Auto_Parry.Parry()
                    end
                    local waitTime = spamThreshold < 1 and 1e-31 or 1e-30
                    task.wait(waitTime)
                end
            end)
            coroutine.resume(autoSpamCoroutine)
        end
        Library.SendNotification({title = "Auto Spam", text = value and "Enabled!" or "Disabled!", duration = 3})
    end
})

auto_Spam:create_dropdown({
    title = "Spam Type",
    flag = "Spam_type",
    options = {"Legit", "Blatant"},
    multi_dropdown = false,
    maximum_options = 1,
    callback = function(value)
        print("Spam Type:", value)
        Auto_Parry.Spam_type = value
    end
})

auto_Spam:create_slider({
    title = "Spam Threshold",
    flag = "Spam_Therhold",
    maximum_value = 3,
    minimum_value = 0.1,
    value = 2,
    round_number = false,
    callback = function(value)
        print("Spam Threshold:", value)
    end
})

auto_Spam:create_checkbox({
    title = "Animation Fix",
    flag = "Animation_Fix",
    callback = function(value)
        print("Animation Fix:", value)
    end
})

auto_Spam:create_checkbox({
    title = "Manual Spam",
    flag = "Manual_Spam",
    callback = function(value)
        print("Manual Spam:", value)
        if value then
            Connections_Manager["Manual_Spam"] = RunService.RenderStepped:Connect(function()
                for remote, args in pairs(revertedRemotes) do
                    if remote:IsA("RemoteEvent") then
                        remote:FireServer(unpack(args))
                    elseif remote:IsA("RemoteFunction") then
                        remote:InvokeServer(unpack(args))
                    end
                end
            end)
        else
            if Connections_Manager["Manual_Spam"] then
                Connections_Manager["Manual_Spam"]:Disconnect()
                Connections_Manager["Manual_Spam"] = nil
            end
        end
    end
})

auto_Spam:create_checkbox({
    title = "Manual Spam UI",
    flag = "Manual_SpamUI",
    callback = function(value)
        print("Manual Spam UI:", value)
        updateUIVisibility(value)
    end
})

-- Utility Module
local speedhack = Detection:create_module({
    title = "Global Infinity Detection",
    flag = "Detection",
    description = "Detects If Infinity is Used",
    section = "left",
    callback = function(value)
        print("")
    end
})

local function applyHeadless(char)
    local head = char:FindFirstChild("Head")
    if head then
        head.Transparency = 1
        for _, dec in ipairs(head:GetChildren()) do
            if dec:IsA("Decal") then
                dec.Transparency = 1
            end
        end
    end
end

local function applyKorbloxLeg(char)
    local rightLeg = char:FindFirstChild("Right Leg") or char:FindFirstChild("RightLowerLeg")
    if rightLeg then
        rightLeg.Transparency = 1
        rightLeg.CanCollide = false
        local existingKorblox = char:FindFirstChild("KorbloxRightLeg")
        if existingKorblox then
            existingKorblox:Destroy()
        end
        local korbloxLeg = Instance.new("MeshPart")
        korbloxLeg.Name = "KorbloxRightLeg"
        korbloxLeg.MeshId = "rbxassetid://902942093"
        korbloxLeg.TextureID = "rbxassetid://902843398"
        korbloxLeg.Size = rightLeg.Size
        korbloxLeg.CFrame = rightLeg.CFrame
        korbloxLeg.Anchored = false
        korbloxLeg.CanCollide = false
        korbloxLeg.Parent = char
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = korbloxLeg
        weld.Part1 = rightLeg
        weld.Parent = korbloxLeg
    end
end

local function removeKorbloxLeg(char)
    local rightLeg = char:FindFirstChild("Right Leg") or char:FindFirstChild("RightLowerLeg")
    if rightLeg then
        rightLeg.Transparency = 0
        rightLeg.CanCollide = true
    end
    local korbloxLeg = char:FindFirstChild("KorbloxRightLeg")
    if korbloxLeg then
        korbloxLeg:Destroy()
    end
end

local function applyHK(char)
    applyHeadless(char)
    applyKorbloxLeg(char)
end

local function removeHK(char)
    removeKorbloxLeg(char)
    local head = char:FindFirstChild("Head")
    if head then
        head.Transparency = 0
        for _, dec in ipairs(head:GetChildren()) do
            if dec:IsA("Decal") then
                dec.Transparency = 0
            end
        end
    end
end

local hkEnabled = false

local Player = player_tab:create_module({
    title = "Headless + Korblox",
    flag = "Player",
    description = "Gives your avatar Headless Head and Korblox right leg",
    section = "left",
    callback = function(value)
        hkEnabled = value
        local char = LocalPlayer.Character
        if char then
            if value then
                applyHK(char)
            else
                removeHK(char)
            end
        end
    end
})

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.5)
    if hkEnabled then
        applyHK(char)
    else
        removeHK(char)
    end
end)

local function applyHeadless()
    local char = LocalPlayer.Character
    if not char then return end
    local head = char:FindFirstChild("Head")
    if head then
        head.Transparency = 1
        for _, dec in ipairs(head:GetChildren()) do
            if dec:IsA("Decal") then
                dec.Transparency = 1
            end
        end
    end
end

local function removeKorblox()
    local char = LocalPlayer.Character
    if not char then return end
    local right_leg = char:FindFirstChild("Right Leg") or char:FindFirstChild("RightLowerLeg")
    if right_leg then
        if right_leg:IsA("MeshPart") then
            right_leg.MeshId = ""
            right_leg.TextureID = ""
        elseif right_leg:IsA("Part") then
            local mesh = right_leg:FindFirstChildOfClass("SpecialMesh")
            if mesh then
                mesh.MeshId = ""
                mesh.TextureId = ""
            end
        end
    end
end

Player:create_checkbox({
    title = "Only Headless",
    flag = "headless",
    callback = function(value)
        if value then
            applyHeadless()
            removeKorblox()
        else
            LocalPlayer:LoadCharacter()
        end
    end
})

LocalPlayer.CharacterAdded:Connect(function()
    if player_tab.flags["headless"] then
        task.wait(0.5)
        applyHeadless()
        removeKorblox()
    end
end)

local skin = Exclusive:create_module({
    title = "Skin Changer",
    flag = "skin",
    description = "Changes Your Sword To Your Desire",
    section = "right",
    callback = function(value)
    end
})

local Imortal = Exclusive:create_module({
    title = "Imortal (Beta)",
    flag = "Imortal",
    description = "Makes You Imortal",
    section = "Left",
    callback = function(state) -- Runs when toggled
        if state then
            -- Get the Players service and local player
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer
            local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

            -- Get the HumanoidRootPart of the character
            local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

            -- Get or create a folder named "Map" in Workspace
            local MapFolder = game.Workspace:FindFirstChild("Map")
            if not MapFolder then
                MapFolder = Instance.new("Folder", workspace)
                MapFolder.Name = "Map"
            end

            -- Clear all children of the Map folder
            for _, child in pairs(MapFolder:GetChildren()) do
                child:Destroy()
            end

            -- Create a platform 20 units below the HumanoidRootPart
            local yOffset = HumanoidRootPart.Position.Y - 20
            local platform = Instance.new("Part")
            platform.Size = Vector3.new(500, 1, 500)
            platform.Position = Vector3.new(HumanoidRootPart.Position.X, yOffset, HumanoidRootPart.Position.Z)
            platform.Anchored = true
            platform.Material = Enum.Material.SmoothPlastic
            platform.Color = Color3.fromRGB(255, 255, 255)
            platform.Parent = MapFolder

            -- Function to remove the platform
            local function removePlatform()
                if platform and platform.Parent then
                    platform:Destroy()
                end
            end

            -- Bind the 'X' key to remove the platform
            local UIS = game:GetService("UserInputService")
            local connection
            connection = UIS.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.KeyCode == Enum.KeyCode.X then
                    removePlatform()
                    if connection then
                        connection:Disconnect()
                    end
                end
            end)

            -- Store so we can clean up later
            Imortal._platform = platform
            Imortal._removeConnection = connection
        else
            -- If toggled off, remove platform & disconnect
            if Imortal._platform and Imortal._platform.Parent then
                Imortal._platform:Destroy()
            end
            if Imortal._removeConnection then
                Imortal._removeConnection:Disconnect()
            end
        end
    end
})

Imortal:create_checkbox({
    title = "Auto Go Underground",
    flag = "Imortalbeta",
    callback = function(state)
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        -- Disconnect old spawn listener if it exists
        if Imortal._spawnConnection then
            Imortal._spawnConnection:Disconnect()
            Imortal._spawnConnection = nil
        end

        if state then
            local function goUnderground()
                local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
                local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

                -- Get or create a folder named "Map" in Workspace
                local MapFolder = game.Workspace:FindFirstChild("Map")
                if not MapFolder then
                    MapFolder = Instance.new("Folder", workspace)
                    MapFolder.Name = "Map"
                end

                -- Clear old platforms
                for _, child in pairs(MapFolder:GetChildren()) do
                    child:Destroy()
                end

                -- Create a platform 20 units below the HumanoidRootPart
                local yOffset = HumanoidRootPart.Position.Y - 20
                local platform = Instance.new("Part")
                platform.Size = Vector3.new(500, 1, 500)
                platform.Position = Vector3.new(HumanoidRootPart.Position.X, yOffset, HumanoidRootPart.Position.Z)
                platform.Anchored = true
                platform.Material = Enum.Material.SmoothPlastic
                platform.Color = Color3.fromRGB(255, 255, 255)
                platform.Parent = MapFolder
            end

            -- Run instantly
            goUnderground()

            -- Also run every time you respawn
            Imortal._spawnConnection = LocalPlayer.CharacterAdded:Connect(function()
                task.wait(1) -- small delay to load
                goUnderground()
            end)
        else
            -- Clean up when unchecked
            if Imortal._spawnConnection then
                Imortal._spawnConnection:Disconnect()
                Imortal._spawnConnection = nil
            end
        end
    end
})

skin:create_textbox({
    title = "Sword Name",
    placeholder = "Enter sword name...",
    flag = "Sword_Name",
    callback = function(text)
        print("Sword set to:", text)
        getgenv().config = {skinChanger = true}
        getgenv().swordModel = text
        getgenv().swordAnimations = text
        getgenv().swordFX = text
        repeat task.wait() until game:IsLoaded()
        if game.GameId ~= 4777817887 then
            return
        end
        local plr = game.Players.LocalPlayer
        local rs = game:GetService("ReplicatedStorage")
        local swordModule = require(rs.Shared.ReplicatedInstances.Swords)
        local controller
        for _, v in getconnections(rs.Remotes.FireSwordInfo.OnClientEvent) do
            local f = v.Function
            if f and islclosure(f) then
                local u = getupvalues(f)
                if type(u[1]) == "table" then
                    controller = u[1]
                    break
                end
            end
        end
        if not controller then
            return
        end
        setupvalue(rawget(swordModule, "EquipSwordTo"), 2, false)
        local data = swordModule:GetSword(getgenv().swordFX)
        local slashName = (data and data.SlashName) or "SlashEffect"
        local function applySword()
            local char = plr.Character or plr.CharacterAdded:Wait()
            swordModule:EquipSwordTo(char, getgenv().swordModel)
            controller:SetSword(getgenv().swordAnimations)
        end
        plr.CharacterAdded:Connect(function()
            task.wait(0.1)
            applySword()
        end)
        applySword()
        local alreadyHooked = false
        for _, v in getconnections(rs.Remotes.ParrySuccessAll.OnClientEvent) do
            if getinfo(v.Function).name == "parrySuccessAll" and not alreadyHooked then
                local original = v.Function
                v:Disable()
                rs.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(...)
                    local args = {...}
                    if tostring(args[4]) == plr.Name and getgenv().config.skinChanger then
                        args[1] = slashName
                        args[3] = getgenv().swordFX
                    end
                    return original(unpack(args))
                end)
                alreadyHooked = true
                break
            end
        end
        Library.SendNotification({title = "Sword Change", text = "Sword set to: " .. text, duration = 3})
    end
})

main:load()
